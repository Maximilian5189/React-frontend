{"ast":null,"code":"import _objectSpread from \"/Users/maximilian/privat/React-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/Users/maximilian/privat/React-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/maximilian/privat/React-frontend/src/components/Input.js\";\nimport React, { useState, useEffect } from 'react';\nimport { IonLabel, IonItem, IonInput, IonNote } from '@ionic/react';\nimport { getFieldErrors } from '../functions/fieldvalidation';\n\nconst Input = props => {\n  const _useState = useState([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        formErrors = _useState2[0],\n        setformErrors = _useState2[1];\n\n  useEffect(() => {\n    function determineErrorMessage() {\n      const field = props.formFields[props.fieldName];\n\n      if (field && field.fieldErrors) {\n        const errorMessages = [];\n\n        for (let _ref of Object.entries(field.fieldErrors)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          let key = _ref2[0];\n          let value = _ref2[1];\n\n          if (value) {\n            errorMessages.push(value);\n          }\n        }\n\n        setformErrors(errorMessages);\n      }\n    }\n\n    determineErrorMessage();\n  }, [props.fieldName, props.formFields, props.setformFields]);\n  useEffect(() => {\n    setformErrors([]);\n  }, [props.tabChanged]);\n\n  function handleUserInput(e) {\n    let fieldValue = e.target.value;\n    const currentField = props.formFields[props.fieldName];\n\n    if (typeof fieldValue == 'undefined') {\n      fieldValue = currentField.fieldValue;\n    }\n\n    const fieldErrors = getFieldErrors(currentField, e.target.value);\n\n    const updatedField = _objectSpread({}, props.formFields[props.fieldName], {}, {\n      fieldValue,\n      fieldErrors\n    });\n\n    props.setformFields(_objectSpread({}, props.formFields, {\n      [props.fieldName]: updatedField\n    }));\n  }\n\n  return React.createElement(React.Fragment, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 43\n    },\n    __self: this\n  }, React.createElement(IonItem, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 44\n    },\n    __self: this\n  }, React.createElement(IonLabel, {\n    position: \"floating\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45\n    },\n    __self: this\n  }, props.fieldName), React.createElement(IonInput, {\n    type: props.type,\n    clearOnEdit: props.clearOnEdit,\n    onIonBlur: e => handleUserInput(e),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 46\n    },\n    __self: this\n  }), formErrors.map((errorMessage, index) => React.createElement(IonNote, {\n    color: \"danger\",\n    key: index,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 47\n    },\n    __self: this\n  }, errorMessage))));\n};\n\nexport default React.memo(Input);","map":{"version":3,"sources":["/Users/maximilian/privat/React-frontend/src/components/Input.js"],"names":["React","useState","useEffect","IonLabel","IonItem","IonInput","IonNote","getFieldErrors","Input","props","formErrors","setformErrors","determineErrorMessage","field","formFields","fieldName","fieldErrors","errorMessages","Object","entries","key","value","push","setformFields","tabChanged","handleUserInput","e","fieldValue","target","currentField","updatedField","type","clearOnEdit","map","errorMessage","index","memo"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { IonLabel, IonItem, IonInput, IonNote } from '@ionic/react';\nimport { getFieldErrors } from '../functions/fieldvalidation';\n\nconst Input = props => {\n    const [formErrors, setformErrors] = useState([]);\n  \n    useEffect(() => {\n      function determineErrorMessage() {\n        const field = props.formFields[props.fieldName];\n        if (field && field.fieldErrors) {\n  \n          const errorMessages = [];\n          for (let [key, value] of Object.entries(field.fieldErrors)) {\n            if (value) {\n              errorMessages.push(value);\n            }\n          }\n          setformErrors(errorMessages)\n        }\n      }\n      determineErrorMessage()\n    }, [props.fieldName, props.formFields, props.setformFields]);\n\n    useEffect(() => {\n      setformErrors([])\n    }, [props.tabChanged])\n\n    function handleUserInput(e) {\n      let fieldValue = e.target.value;\n      const currentField = props.formFields[props.fieldName];\n      if (typeof fieldValue == 'undefined') {\n        fieldValue = currentField.fieldValue\n      }\n\n      const fieldErrors= getFieldErrors(currentField, e.target.value)\n\n      const updatedField = {...props.formFields[props.fieldName], ...{fieldValue, fieldErrors}}\n      props.setformFields({...props.formFields, [props.fieldName]: updatedField})\n    }\n\n    return (\n      <React.Fragment>\n        <IonItem>\n          <IonLabel position=\"floating\">{props.fieldName}</IonLabel>\n          <IonInput type={props.type} clearOnEdit={props.clearOnEdit} onIonBlur={e => handleUserInput(e)}/>\n          {formErrors.map((errorMessage, index) => <IonNote color=\"danger\" key={index}>{errorMessage}</IonNote>)}\n        </IonItem>\n      </React.Fragment>\n    )\n}\n\nexport default React.memo(Input)"]},"metadata":{},"sourceType":"module"}